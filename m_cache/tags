!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
ALLOCHEUR	./wcrt/header.h	/^char ALLOCHEUR = 0;$/;"	v
ALWAYS_HIT	./header.h	91;"	d
ALWAYS_MISS	./header.h	92;"	d
ASYNCH	./wcrt/header.h	26;"	d
BAconflictInPath	./DAG_WCET.c	/^char BAconflictInPath( block *bu, block *bv, path *pv, block **bblist, int num_bb ) {$/;"	f
BBconflictInPath	./DAG_WCET.c	/^char BBconflictInPath( branch *bru, char direction, block *bv, path *pv, block **bblist, int num_bb ) {$/;"	f
BE	./infeasible.h	20;"	d
BT	./infeasible.h	19;"	d
CACHE_LINE	./header.h	54;"	d
CACHE_LINE_L2	./header.h	64;"	d
CALLOC	./handler.c	29;"	d	file:
CALLOC	./wcrt/handler.c	30;"	d	file:
CHMC	./header.h	/^}CHMC;$/;"	t	typeref:struct:__anon14
CLEAR_LSB	./header.h	75;"	d
CLEAR_LSB_L2	./header.h	77;"	d
CLUSTER_BASED	./wcrt/header.h	35;"	d
CPU_MHZ	./main.c	39;"	d	file:
CYCLES_PER_MSEC	./handler.c	18;"	d	file:
CYCLES_PER_MSEC	./wcrt/handler.c	17;"	d	file:
CYCLE_TIME_H	./cycle_time.h	2;"	d
CYCLE_TIME_H	./wcrt/cycle_time.h	2;"	d
DAG	./header.h	30;"	d
DEBUG	./wcrt/header.h	/^char DEBUG = 0;$/;"	v
DEBUGSLACK	./slacks.c	1;"	d	file:
DEBUGSLACK	./wcrt/slacks.c	2;"	d	file:
DEBUGTHIS	./timing.c	7;"	d	file:
DEBUGTHIS	./wcrt/timing.c	7;"	d	file:
DEFAULT_ALLOCWEIGHT	./wcrt/header.h	19;"	d
DEFAULT_LIMITSOLN	./wcrt/header.h	22;"	d
DEFAULT_OFF_LATENCY	./wcrt/header.h	14;"	d
DEFAULT_SPM_LATENCY	./wcrt/header.h	13;"	d
DERI_LEN	./infeasible.h	12;"	d
DOWNTIME_TOLERANCE	./wcrt/header.h	16;"	d
DP_knapsack	./wcrt/knapsack.c	/^int DP_knapsack( int capacity, int num_items, int *gain, int *weight, char *alloc ) {$/;"	f
ENUM	./header.h	31;"	d
EQ	./infeasible.h	23;"	d
FALL	./infeasible.h	17;"	d
FETCH_SIZE	./wcrt/header.h	11;"	d
FIRST_ITERATION	./header.h	40;"	d
FIRST_MISS	./header.h	93;"	d
GET_CALLEE	./header.h	480;"	d
GRAPH_COLORING	./wcrt/header.h	32;"	d
GREEDY	./wcrt/header.h	/^char GREEDY = 1;$/;"	v
HIT	./header.h	101;"	d
HIT_UPPER	./header.h	95;"	d
IC_HIT	./header.h	81;"	d
IC_HIT_L2	./header.h	85;"	d
IC_MISS	./header.h	82;"	d
IC_MISS_L2	./header.h	86;"	d
ILP	./header.h	29;"	d
ILPconstDAG	./analysisILP.c	/^int ILPconstDAG( char objtype, void *obj ) {$/;"	f
ILPconstProc	./analysisILP.c	/^int ILPconstProc( procedure *p ) {$/;"	f
INSN_EXEC_TIME	./wcrt/header.h	8;"	d
INSN_LEN	./infeasible.h	13;"	d
INSN_SIZE	./header.h	33;"	d
INSN_SIZE	./wcrt/header.h	10;"	d
INTERFERENCE_CLUSTER	./wcrt/header.h	31;"	d
INVALID	./header.h	42;"	d
IS_CALL	./header.h	479;"	d
JUMP	./infeasible.h	16;"	d
KO	./infeasible.h	30;"	d
L1_HIT	./header.h	/^	L1_HIT,$/;"	e	enum:acc_tag
L1_HIT_LATENCY	./header.h	475;"	d
L2_HIT	./header.h	/^	L2_HIT$/;"	e	enum:acc_tag
L2_HIT_LATENCY	./header.h	476;"	d
L2_MISS	./header.h	/^	L2_MISS = 0,$/;"	e	enum:acc_tag
LOOP	./analysis.h	6;"	d
LSB_OFF	./header.h	59;"	d
LSB_OFF_L2	./header.h	69;"	d
LSB_ON	./header.h	60;"	d
LSB_ON_L2	./header.h	70;"	d
MALLOC	./handler.c	25;"	d	file:
MALLOC	./wcrt/handler.c	26;"	d	file:
MAXCR	./wcrt/header.h	5;"	d
MAXLEN	./wcrt/header.h	4;"	d
MAXSTEP	./wcrt/header.h	3;"	d
MAX_BUS_DELAY	./header.h	478;"	d
MAX_CACHE_SETS	./header.h	44;"	d
MAX_LEN	./header.h	46;"	d
MAX_NEST_LOOP	./header.h	45;"	d
MAX_TAG_BITS	./header.h	52;"	d
MAX_UNFOLD	./wcrt/header.h	6;"	d
MBLK_ID	./header.h	79;"	d
MC_INC_SIZE	./header.h	88;"	d
MISS	./header.h	100;"	d
MISS_PENALTY	./header.h	477;"	d
MSC	./header.h	/^}MSC;$/;"	t	typeref:struct:__anon21
NA	./infeasible.h	25;"	d
NAMELEN	./wcrt/handler.c	21;"	d	file:
NE	./infeasible.h	24;"	d
NEXT_ITERATION	./header.h	41;"	d
NIL	./infeasible.h	31;"	d
NONE	./wcrt/header.h	29;"	d
NOT_USED	./header.h	97;"	d
NO_REG	./infeasible.h	14;"	d
OP_LEN	./header.h	27;"	d
PARTITION_CORE	./header.h	492;"	d
PEList	./wcrt/header.h	/^  sched_t **PEList;$/;"	m	struct:__anon9
PROC	./analysis.h	5;"	d
PROFILE_KNAPSACK	./wcrt/header.h	30;"	d
REALLOC	./handler.c	33;"	d	file:
REALLOC	./wcrt/handler.c	34;"	d	file:
REG_RETURN	./infeasible.h	8;"	d
SCHED_TYPE_1	./header.h	/^	SCHED_TYPE_1 = 0,$/;"	e	enum:__anon22
SCHED_TYPE_2	./header.h	/^	SCHED_TYPE_2,$/;"	e	enum:__anon22
SCHED_TYPE_3	./header.h	/^	SCHED_TYPE_3$/;"	e	enum:__anon22
SE	./infeasible.h	22;"	d
SET	./header.h	55;"	d
SET_L2	./header.h	65;"	d
SLACK_CRITICAL	./wcrt/header.h	33;"	d
SLT	./infeasible.h	33;"	d
SLTI	./infeasible.h	32;"	d
ST	./infeasible.h	21;"	d
STARTTIME	./handler.c	19;"	d	file:
STARTTIME	./wcrt/handler.c	18;"	d	file:
STOPTIME	./handler.c	20;"	d	file:
STOPTIME	./wcrt/handler.c	19;"	d	file:
SYNCH	./wcrt/header.h	25;"	d
TAG	./header.h	56;"	d
TAGSET	./header.h	57;"	d
TAGSET2	./header.h	58;"	d
TAGSET2_L2	./header.h	68;"	d
TAGSET_L2	./header.h	67;"	d
TAG_L2	./header.h	66;"	d
UNKNOW	./header.h	94;"	d
UNROLL	./header.h	34;"	d
USED	./header.h	98;"	d
acc_bus_delay	./header.h	/^uint acc_bus_delay;$/;"	v
acc_t	./header.h	/^  enum acc_tag* acc_t;$/;"	m	struct:__anon12	typeref:enum:__anon12::acc_tag
acc_t_l2	./header.h	/^  enum acc_tag* acc_t_l2;$/;"	m	struct:__anon12	typeref:enum:__anon12::acc_tag
acc_tag	./header.h	/^typedef enum acc_tag{$/;"	g
acc_type	./header.h	/^} acc_type;	$/;"	t	typeref:enum:acc_tag
access_counter	./cycle_time.c	/^access_counter(unsigned *hi, unsigned *lo)$/;"	f	file:
access_counter	./wcrt/cycle_time.c	/^access_counter(unsigned *hi, unsigned *lo)$/;"	f	file:
actorID	./wcrt/header.h	/^  int    actorID;$/;"	m	struct:__anon8
addAssign	./findConflicts.c	/^int addAssign( char deri_tree[], block *bb, int lineno, int rhs, char rhs_var ) {$/;"	f
addBranch	./findConflicts.c	/^int addBranch( char deri_tree[], block *bb, int rhs, char rhs_var, char jump_cond ) {$/;"	f
addChartTasks	./timingMSG.c	/^int addChartTasks( int chartid, chart_t *ctx ) {$/;"	f
addChartTasks	./wcrt/timingMSG.c	/^int addChartTasks( int chartid, chart_t *ctx ) {$/;"	f
addConcatDependency	./timingMSG.c	/^int addConcatDependency( chart_t *cx, int **predRecord, int **succRecord, int *recordLen ) {$/;"	f
addConcatDependency	./wcrt/timingMSG.c	/^int addConcatDependency( chart_t *cx, int **predRecord, int **succRecord, int *recordLen ) {$/;"	f
addFreq	./analysis.c	/^int addFreq( task_t *tc, int fnid, int bbid, int freq ) {$/;"	f
addFreq	./wcrt/analysis.c	/^int addFreq( task_t *tc, int fnid, int bbid, int freq ) {$/;"	f
addToLoop	./loopdetect.c	/^int addToLoop( loop *lp, block *bb, char check ) {$/;"	f
addr	./header.h	/^  char addr[OP_LEN];$/;"	m	struct:__anon12
addr	./wcrt/header.h	/^  int addr;$/;"	m	struct:__anon7
age	./header.h	/^    char *hit_change_miss, *age;$/;"	m	struct:__anon14
all_inst	./header.h	/^ull all_inst;$/;"	v
allocCacheState	./analysisCache.c	/^allocCacheState()$/;"	f	file:
allocCacheState_L2	./analysisCacheL2.c	/^allocCacheState_L2()$/;"	f	file:
alloc_t	./wcrt/header.h	/^} alloc_t;$/;"	t	typeref:struct:__anon5
allocated	./wcrt/header.h	/^  char   *allocated;$/;"	m	struct:__anon8
allocmethod	./wcrt/header.h	/^char allocmethod;$/;"	v
allocweight	./wcrt/header.h	/^double allocweight;$/;"	v
analyseDAGFunction	./analysisDAG.c	/^int analyseDAGFunction(procedure *proc, int index)$/;"	f
analyseDAGFunction_BCET	./analysisDAG_BCET.c	/^int analyseDAGFunction_BCET(procedure *proc, int index)$/;"	f
analyseDAGFunction_WCET	./analysisDAG_WCET.c	/^int analyseDAGFunction_WCET(procedure *proc, int index)$/;"	f
analyseDAGLoop	./analysisDAG.c	/^int analyseDAGLoop(procedure *proc, loop *lop, int index ) $/;"	f
analyseDAGLoop_BCET	./analysisDAG_BCET.c	/^int analyseDAGLoop_BCET(procedure *proc, loop *lop, int index ) $/;"	f
analyseDAGLoop_WCET	./analysisDAG_WCET.c	/^int analyseDAGLoop_WCET(procedure *proc, loop *lop, int index ) $/;"	f
analyseEnumDAG	./analysisEnum.c	/^int analyseEnumDAG( char objtype, void *obj ) {$/;"	f
analyseEnumProc	./analysisEnum.c	/^int analyseEnumProc( procedure *p ) {$/;"	f
analyseProc	./analysisDAG.c	/^int analyseProc( procedure *p ) {$/;"	f
analyseProc_BCET	./analysisDAG_BCET.c	/^int analyseProc_BCET( procedure *p ) {$/;"	f
analyseProc_WCET	./analysisDAG_WCET.c	/^int analyseProc_WCET( procedure *p ) {$/;"	f
analysis_dag	./analysisDAG.c	/^int analysis_dag(MSC *msc) {$/;"	f
analysis_dag_BCET	./analysisDAG_BCET.c	/^int analysis_dag_BCET(MSC *msc) {$/;"	f
analysis_dag_WCET	./analysisDAG_WCET.c	/^int analysis_dag_WCET(MSC *msc) {$/;"	f
analysis_enum	./analysisEnum.c	/^int analysis_enum() {$/;"	f
analysis_ilp	./analysisILP.c	/^int analysis_ilp() {$/;"	f
assign	./infeasible.h	/^} assign;$/;"	t	typeref:struct:__anon2
assignedList	./wcrt/header.h	/^  int *assignedList;      \/\/ task index (not pid!) of assigned tasks, not ordered$/;"	m	struct:__anon6
assignlist	./infeasible.h	/^assign ****assignlist;         \/\/ assignlist[i][j]: list of assign effects (ptr) in proc i block j$/;"	v
assignsTo	./DAG_WCET.c	/^char assignsTo( block *bb, char *addr ) {$/;"	f
bb	./infeasible.h	/^  block  *bb;                  \/\/ associated block$/;"	m	struct:__anon2
bb	./infeasible.h	/^  block  *bb;                  \/\/ associated block$/;"	m	struct:brch
bb_cache_state	./header.h	/^  cache_state *bb_cache_state, *bb_cache_state_L2;$/;"	m	struct:__anon17
bb_cache_state_L2	./header.h	/^  cache_state *bb_cache_state, *bb_cache_state_L2;$/;"	m	struct:__anon17
bb_len	./infeasible.h	/^  int    bb_len;$/;"	m	struct:__anon3
bb_seq	./infeasible.h	/^  int    *bb_seq;              \/\/ block id-s$/;"	m	struct:__anon3
bbid	./header.h	/^  int   bbid;$/;"	m	struct:__anon17
bbid	./wcrt/header.h	/^  int fnid, bbid;         \/\/ for analysis$/;"	m	struct:__anon7
bblist	./header.h	/^  block **bblist;       \/\/ list of basic blocks in the procedure$/;"	m	struct:procs
bcet	./header.h	/^    ull bcet;$/;"	m	struct:__anon20
bcet	./header.h	/^  ull    *bcet;$/;"	m	struct:__anon18
bcet	./header.h	/^  ull    *bcet;$/;"	m	struct:procs
bcost	./header.h	/^    uint  bcost;           \/\/ block execution time: best case for cache analysis$/;"	m	struct:__anon14
bcost_copy	./header.h	/^    uint  bcost_copy;$/;"	m	struct:__anon14
binSearch	./block.c	/^block* binSearch( int addr, block **bblist, int start, int end ) {$/;"	f
block	./header.h	/^} block;$/;"	t	typeref:struct:__anon17
bound	./wcrt/header.h	/^  int bound;$/;"	m	struct:__anon10
branch	./infeasible.h	/^} branch;$/;"	t	typeref:struct:brch
branch_dir	./infeasible.h	/^  char   *branch_dir;          \/\/ direction taken by each branch in this path$/;"	m	struct:__anon3
branch_eff	./infeasible.h	/^  branch **branch_eff;         \/\/ branch effects, NULL if the corresponding branch has no effect$/;"	m	struct:__anon3
branch_len	./infeasible.h	/^  int    branch_len;$/;"	m	struct:__anon3
branchlist	./infeasible.h	/^branch ***branchlist;          \/\/ branchlist[i][j]: branch effect (ptr) associated with proc i block j$/;"	v
brch	./infeasible.h	/^typedef struct brch {$/;"	s
cache	./header.h	/^cache_t cache, cache_L2;$/;"	v
cacheAnalysis	./analysisCache.c	/^cacheAnalysis(){$/;"	f	file:
cacheAnalysis_L2	./analysisCacheL2.c	/^cacheAnalysis_L2()$/;"	f	file:
cache_L2	./header.h	/^cache_t cache, cache_L2;$/;"	v
cache_config	./header.h	/^char *cache_config;$/;"	v
cache_config_L2	./header.h	/^char *cache_config_L2;$/;"	v
cache_line_way_t	./header.h	/^} cache_line_way_t;$/;"	t	typeref:struct:__anon15
cache_state	./header.h	/^} cache_state;$/;"	t	typeref:struct:__anon16
cache_t	./header.h	/^} cache_t;$/;"	t	typeref:struct:__anon13
calculateCacheState	./analysisCache.c	/^calculateCacheState(cache_line_way_t **must, cache_line_way_t **may, cache_line_way_t **persist, int instr_addr)$/;"	f	file:
calculateCacheState_L2	./analysisCacheL2.c	/^calculateCacheState_L2(cache_line_way_t **must, cache_line_way_t **may, cache_line_way_t **persist, int instr_addr)$/;"	f	file:
calculateMay	./analysisCache.c	/^calculateMay(cache_line_way_t **may, int instr_addr)$/;"	f	file:
calculateMay_L2	./analysisCacheL2.c	/^calculateMay_L2(cache_line_way_t **may, int instr_addr)$/;"	f	file:
calculateMust	./analysisCache.c	/^calculateMust(cache_line_way_t **must, int instr_addr)$/;"	f	file:
calculateMust_L2	./analysisCacheL2.c	/^calculateMust_L2(cache_line_way_t **must, int instr_addr)$/;"	f	file:
calculatePersist	./analysisCache.c	/^calculatePersist(cache_line_way_t **persist, int instr_addr)$/;"	f	file:
calculatePersist_L2	./analysisCacheL2.c	/^calculatePersist_L2(cache_line_way_t **persist, int instr_addr)$/;"	f	file:
calculate_incoming	./parseCFG.c	/^  calculate_incoming()$/;"	f	file:
callpid	./header.h	/^  int   callpid;        \/\/ id of called procedure (by compiler convention, at most one per block)$/;"	m	struct:__anon17
calls	./header.h	/^  int   *calls;         \/\/ id-s of called procedure$/;"	m	struct:procs
canConflict	./timing.c	/^int canConflict( int suspect, int victim ) {$/;"	f
canConflict	./wcrt/timing.c	/^int canConflict( int suspect, int victim ) {$/;"	f
canPreempt	./timing.c	/^char canPreempt( int suspect, int victim ) {$/;"	f
canPreempt	./wcrt/timing.c	/^char canPreempt( int suspect, int victim ) {$/;"	f
cancelEffect	./pathTest.c	/^void cancelEffect(int effectNo){$/;"	f
cfname	./wcrt/header.h	/^char *cfname;$/;"	v
chart_t	./wcrt/header.h	/^} chart_t;$/;"	t	typeref:struct:__anon9
checkLoop	./loopdetect.c	/^int checkLoop( procedure *p, block *bb, char outid, int level ) {$/;"	f
check_hit_miss	./analysisDAG_WCET.c	/^acc_type check_hit_miss(block* bb, instr* inst)$/;"	f
check_loop	./analysisDAG_WCET.c	/^static loop* check_loop(block* bb, procedure* proc)$/;"	f	file:
chmc	./header.h	/^  CHMC **chmc, **chmc_L2;$/;"	m	struct:__anon17
chmc_L2	./header.h	/^  CHMC **chmc, **chmc_L2;$/;"	m	struct:__anon17
classify_inst	./analysisDAG_WCET.c	/^static void classify_inst(instr* inst, CHMC** chmc, int n_chmc, int inst_id)$/;"	f	file:
classify_inst_BCET	./analysisDAG_WCET.c	/^static void classify_inst_BCET(instr* inst, CHMC** chmc, int n_chmc, int inst_id)$/;"	f	file:
classify_inst_L2	./analysisDAG_WCET.c	/^static void classify_inst_L2(instr* inst, CHMC** chmc_l2, int n_chmc_l2, int inst_id)$/;"	f	file:
classify_inst_L2_BCET	./analysisDAG_WCET.c	/^static void classify_inst_L2_BCET(instr* inst, CHMC** chmc_l2, int n_chmc_l2,$/;"	f	file:
clearReg	./infeasible.c	/^int clearReg() {$/;"	f
cmp	./header.h	/^    int     cmp;    \/\/ Level one cache miss penalty$/;"	m	struct:__anon13
collectStartTasks	./wcrt/topo.c	/^int collectStartTasks( int *taskIDList, int numChartTasks, int **startTaskList ) {$/;"	f
colorAllocation	./wcrt/graphcoloring.c	/^int colorAllocation( chart_t *msc, overlay_t *ox, char *colorAssg, int numColors, int capacity ) {$/;"	f
colorPartition	./wcrt/graphcoloring.c	/^int colorPartition( int *memberList, int numMembers, char *colorAssg, int **colorShare, int capacity ) {$/;"	f
comesBefore	./slacks.c	/^char comesBefore( int pred, int succ, chart_t *msc ) {$/;"	f
comesBefore	./wcrt/slacks.c	/^char comesBefore( int pred, int succ, chart_t *msc ) {$/;"	f
computeBCET	./analysisDAG_WCET.c	/^void computeBCET(ull start_time)$/;"	f
computeBCET_block	./analysisDAG_WCET.c	/^static void computeBCET_block(block* bb, procedure* proc, loop* cur_lp)$/;"	f	file:
computeBCET_loop	./analysisDAG_WCET.c	/^static void computeBCET_loop(loop* lp, procedure* proc)$/;"	f	file:
computeBCET_proc	./analysisDAG_WCET.c	/^static void computeBCET_proc(procedure* proc, ull start_time)$/;"	f	file:
computeWCET	./analysisDAG_WCET.c	/^void computeWCET(ull start_time)$/;"	f
computeWCET_block	./analysisDAG_WCET.c	/^static void computeWCET_block(block* bb, procedure* proc, loop* cur_lp)$/;"	f	file:
computeWCET_loop	./analysisDAG_WCET.c	/^static void computeWCET_loop(loop* lp, procedure* proc)$/;"	f	file:
computeWCET_proc	./analysisDAG_WCET.c	/^static void computeWCET_proc(procedure* proc, ull start_time)$/;"	f	file:
computeWCRT	./timing.c	/^time_t computeWCRT( chart_t *msc ) {$/;"	f
computeWCRT	./wcrt/timing.c	/^time_t computeWCRT( chart_t *msc ) {$/;"	f
compute_bus_BCET_MSC	./analysisDAG_WCET.c	/^void compute_bus_BCET_MSC(MSC *msc) {$/;"	f
compute_bus_WCET_MSC	./analysisDAG_WCET.c	/^void compute_bus_WCET_MSC(MSC *msc) {$/;"	f
compute_bus_delay	./analysisDAG_WCET.c	/^static int compute_bus_delay(ull start_time, uint ncore, acc_type type)$/;"	f	file:
compute_waiting_time	./analysisDAG_WCET.c	/^uint compute_waiting_time(core_sched_p head_core, ull start_time, acc_type type)$/;"	f
concat	./wcrt/header.h	/^char concat;$/;"	v
conflictStatistics	./updateCacheL2.c	/^conflictStatistics(MSC *msc, int index, int set_no, int current_addr)$/;"	f	file:
conflictdir	./infeasible.h	/^  char   *conflictdir;         \/\/ directions of the conflicting branches$/;"	m	struct:__anon2
conflictdir_fall	./infeasible.h	/^  char   *conflictdir_fall;    \/\/ directions of branches conflicting with this branch's fall direction $/;"	m	struct:brch
conflictdir_jump	./infeasible.h	/^  char   *conflictdir_jump;    \/\/ directions of branches conflicting with this branch's jump direction $/;"	m	struct:brch
conflicts	./infeasible.h	/^  branch **conflicts;          \/\/ conflicting branches (outgoing)$/;"	m	struct:__anon2
conflicts	./infeasible.h	/^  struct brch **conflicts;     \/\/ conflicting branches (outgoing)$/;"	m	struct:brch	typeref:struct:brch::brch
constructAll	./analysisCache.c	/^constructAll(task_t *task)$/;"	f	file:
constructFunctionCall	./analysisCache.c	/^constructFunctionCall(procedure *pro, task_t *task)$/;"	f	file:
copyBlock	./analysisCache.c	/^copyBlock(block *bb)$/;"	f	file:
copyCacheSet	./analysisCacheL2.c	/^copyCacheSet(cache_line_way_t **cache_set)$/;"	f	file:
copyCacheSet_persist	./analysisCacheL2.c	/^copyCacheSet_persist(cache_line_way_t **cache_set)$/;"	f	file:
copyCacheState	./analysisCache.c	/^copyCacheState(cache_state *cs)$/;"	f	file:
copyCacheState_L2	./analysisCacheL2.c	/^copyCacheState_L2(cache_state *cs)$/;"	f	file:
copyChart	./timingMSG.c	/^int copyChart( chart_t *new, chart_t *src, int lastnode, char nextsucc ) {$/;"	f
copyChart	./wcrt/timingMSG.c	/^int copyChart( chart_t *new, chart_t *src, int lastnode, char nextsucc ) {$/;"	f
copyFunction	./analysisCache.c	/^copyFunction(procedure* proc)$/;"	f	file:
copyLoop	./analysisCache.c	/^copyLoop(procedure *proc, procedure* copy_proc, loop *lp)$/;"	f	file:
copyPath	./timingMSG.c	/^int copyPath( path_t *new, path_t *src, int lastnode, char nextsucc ) {$/;"	f
copyPath	./wcrt/timingMSG.c	/^int copyPath( path_t *new, path_t *src, int lastnode, char nextsucc ) {$/;"	f
copySeq	./path.c	/^int copySeq( path *p1, path *p2 ) {$/;"	f
copyTask	./timingMSG.c	/^int copyTask( task_t *dst, task_t *src ) {$/;"	f
copyTask	./wcrt/timingMSG.c	/^int copyTask( task_t *dst, task_t *src ) {$/;"	f
core_sched	./header.h	/^struct core_sched {$/;"	s
core_sched_p	./header.h	/^typedef struct core_sched* core_sched_p;$/;"	t	typeref:struct:core_sched
core_sched_s	./header.h	/^typedef struct core_sched core_sched_s;$/;"	t	typeref:struct:core_sched
cost	./infeasible.h	/^  ull    cost;$/;"	m	struct:__anon3
countEdge	./timingMSG.c	/^int countEdge( path_t *px, int src, int dst ) {$/;"	f
countEdge	./wcrt/timingMSG.c	/^int countEdge( path_t *px, int src, int dst ) {$/;"	f
countInstrLast	./parseCFG.c	/^int countInstrLast( int lastaddr ) {$/;"	f
countInstrPrev	./parseCFG.c	/^int countInstrPrev( block *bb ) {$/;"	f
createBlock	./parseCFG.c	/^int createBlock( block *bb, int pid, int bbid, int startaddr, int tb, int nb, int callpid, int loopid ) {$/;"	f
createInstr	./parseCFG.c	/^int createInstr( instr *i, int addr, char *op, char *r1, char *r2, char *r3 ) {$/;"	f
createLoop	./parseCFG.c	/^int createLoop( loop *lp, int pid, int lpid, int level, block *loophead ) {$/;"	f
createProc	./parseCFG.c	/^int createProc( procedure *p, int pid ) {$/;"	f
ctimeHi	./wcrt/header.h	/^  time_t ctimeHi;          \/\/ upper bound of computation time$/;"	m	struct:__anon8
ctimeLo	./wcrt/header.h	/^  time_t ctimeLo;          \/\/ lower bound of computation time$/;"	m	struct:__anon8
cur_context	./header.h	/^uint cur_context;$/;"	v
cur_task	./header.h	/^task_t* cur_task;$/;"	v
cycle_time	./cycle_time.c	/^cycle_time(int start_end)$/;"	f
cycle_time	./wcrt/cycle_time.c	/^cycle_time(int start_end)$/;"	f
debug	./header.h	/^char debug;             \/\/ text dump on\/off$/;"	v
dequeue	./wcrt/util.c	/^int dequeue( int **arr, int *len ) {$/;"	f
deri_tree	./infeasible.h	/^  char   deri_tree[DERI_LEN];  \/\/ derivation tree of affected variable$/;"	m	struct:__anon2
deri_tree	./infeasible.h	/^  char   deri_tree[DERI_LEN];  \/\/ derivation tree of tested variable$/;"	m	struct:brch
deri_tree	./infeasible.h	/^} deri_tree;                   \/\/ derivation of the value of a register$/;"	t	typeref:struct:__anon1
detectConflictTopo	./findConflicts.c	/^int detectConflictTopo( procedure *p, block **bblist, int num_bb, int lpid ) {$/;"	f
detectConflicts	./findConflicts.c	/^int detectConflicts() {$/;"	f
detectDirection	./DAG_WCET.c	/^int detectDirection( branch *bru, block *bv ) {$/;"	f
detect_loops	./loopdetect.c	/^int detect_loops() {$/;"	f
determineLoopExits	./loopdetect.c	/^int determineLoopExits( loop **loops, int num_loops, block **bblist, int num_bb ) {$/;"	f
determine_latency	./analysisDAG_WCET.c	/^uint determine_latency(block* bb, uint context, uint bb_cost, acc_type type)$/;"	f
dgname	./wcrt/header.h	/^char *dgname;$/;"	v
doAllocation	./wcrt/selectcontent.c	/^int doAllocation( chart_t *msc, overlay_t *ox, int capacity ) {$/;"	f
doAllocationILP	./wcrt/selectcontent.c	/^int doAllocationILP( chart_t *msc, overlay_t *ox, int capacity ) {$/;"	f
doAllocationKnapsack	./wcrt/selectcontent.c	/^int doAllocationKnapsack( overlay_t *ox, int capacity ) {$/;"	f
doClustering	./wcrt/cluster.c	/^char doClustering( sched_t *sc, chart_t *msc ) {$/;"	f
doTiming	./slacks.c	/^char doTiming( chart_t *msc, char slack ) {$/;"	f
doTiming	./wcrt/slacks.c	/^char doTiming( chart_t *msc, char slack ) {$/;"	f
do_inline	./analysis.h	/^char do_inline = 0;$/;"	v
dpmin	./wcrt/dp.c	/^int dpmin( int N, int S, double **val ) {$/;"	f
dst	./wcrt/header.h	/^  int dst;$/;"	m	struct:__anon10
dumpCacheConfig	./analysisCache.c	/^dumpCacheConfig()$/;"	f	file:
dumpCacheConfig_L2	./analysisCacheL2.c	/^dumpCacheConfig_L2()$/;"	f	file:
dumpCacheState	./dump.c	/^dumpCacheState(cache_state *cs)$/;"	f	file:
dumpCacheState_L2	./dump.c	/^dumpCacheState_L2(cache_state *cs)$/;"	f	file:
dumpInterference	./slacks.c	/^int dumpInterference( chart_t *msc ) {$/;"	f
dumpInterference	./wcrt/slacks.c	/^int dumpInterference( chart_t *msc ) {$/;"	f
dumpProcCopy	./dump.c	/^dumpProcCopy(task_t *task)$/;"	f	file:
dumpTaskInfo	./wcrt/dump.c	/^int dumpTaskInfo() {$/;"	f
dumpTaskInfo_dep	./wcrt/dump.c	/^int dumpTaskInfo_dep() {$/;"	f
dump_cache_line	./analysisCache.c	/^dump_cache_line(cache_line_way_t *clw_a)$/;"	f	file:
dump_callgraph	./dump.c	/^int dump_callgraph() {$/;"	f
dump_loops	./dump.c	/^int dump_loops() {$/;"	f
dump_pre_proc_chmc	./analysisDAG_WCET.c	/^static void dump_pre_proc_chmc(procedure* proc)$/;"	f	file:
dump_prog_info	./analysisDAG_WCET.c	/^static void dump_prog_info(procedure* proc)$/;"	f	file:
earliestFin	./wcrt/header.h	/^time_t *earliestFin;$/;"	v
earliestReq	./wcrt/header.h	/^time_t *earliestReq;$/;"	v
earliestTimes	./timing.c	/^char earliestTimes( chart_t *msc, int *topoArr, int toposize ) {$/;"	f
earliestTimes	./wcrt/timing.c	/^char earliestTimes( chart_t *msc, int *topoArr, int toposize ) {$/;"	f
earliestTimes_slack	./slacks.c	/^char earliestTimes_slack( chart_t *msc, int *topoArr, int toposize ) {$/;"	f
earliestTimes_slack	./wcrt/slacks.c	/^char earliestTimes_slack( chart_t *msc, int *topoArr, int toposize ) {$/;"	f
edgeBounds	./wcrt/header.h	/^  char **edgeBounds;$/;"	m	struct:__anon11
edgeBounds	./wcrt/header.h	/^edge_t *edgeBounds;       \/\/ bounds of back edges in the MSG$/;"	v
edge_t	./wcrt/header.h	/^} edge_t;$/;"	t	typeref:struct:__anon10
effectCancelled	./DAG_WCET.c	/^int effectCancelled( branch *br, assign *assg, path *pv, block **bblist, int num_bb ) {$/;"	f
endNode	./wcrt/header.h	/^int endNode;              \/\/ index of end node of the MSG (assumed single; may still have outgoing edges if MSG is cyclic)$/;"	v
enqueue	./wcrt/util.c	/^int enqueue( int element, int **arr, int *len ) {$/;"	f
enqueuePair	./wcrt/util.c	/^int enqueuePair( int element1, int **arr1, int element2, int **arr2, int *len ) {$/;"	f
enqueueUnique	./wcrt/util.c	/^int enqueueUnique( int element, int **arr, int *len ) {$/;"	f
entry	./header.h	/^    int *entry;    \/\/ entry address$/;"	m	struct:__anon15
entry_proc	./header.h	/^    procedure* entry_proc;$/;"	m	struct:__anon20
enum_BAconflictInPath	./analysisEnum.c	/^char enum_BAconflictInPath( block *bu, ushort *bb_seq, ushort len, block **bblist, int num_bb ) {$/;"	f
enum_BBconflictInPath	./analysisEnum.c	/^char enum_BBconflictInPath( branch *bru, char direction, block *bv, $/;"	f
enum_effectCancelled	./analysisEnum.c	/^int enum_effectCancelled( branch *br, assign *assg, ushort *bb_seq, ushort len, block **bblist, int num_bb ) {$/;"	f
enum_findBranch	./analysisEnum.c	/^int enum_findBranch( branch *br, ushort *bb_seq, ushort len ) {$/;"	f
enum_in_seq_bef	./analysisEnum.c	/^char enum_in_seq_bef( int bbid, int target, ushort *bb_seq, ushort bb_len ) {$/;"	f
enum_pathlen	./analysis.h	/^unsigned short ***enum_pathlen;    \/\/ enum_pathlen[p][b][n]: length of the n-th path in enum_pathlist[p][b]$/;"	v
enum_pathlist	./analysis.h	/^unsigned short ****enum_pathlist;  \/\/ enum_pathlist[p][b]: list of enumerated paths kept at proc. p block b$/;"	v
enum_paths_loop	./analysis.h	/^ull *enum_paths_loop;  \/\/ number of paths in each loop (in currently analysed procedure)$/;"	v
enum_paths_proc	./analysis.h	/^ull *enum_paths_proc;  \/\/ number of paths in each procedure$/;"	v
estGain	./slacks.c	/^time_t estGain( task_t *ts, int capacity ) {$/;"	f
estGain	./wcrt/slacks.c	/^time_t estGain( task_t *ts, int capacity ) {$/;"	f
execute	./findConflicts.c	/^int execute() {$/;"	f
extractTaskName	./wcrt/dump.c	/^char* extractTaskName( char *fullname ) {$/;"	f
filename	./header.h	/^char *filename;$/;"	v
fin_opt	./header.h	/^  ull fin_opt[64];$/;"	m	struct:__anon18
fin_opt	./header.h	/^ ull fin_opt[64];$/;"	m	struct:__anon17
findBlock	./block.c	/^block* findBlock( int addr ) {$/;"	f
findBranch	./path.c	/^int findBranch( branch *br, branch **branch_eff, int branch_len ) {$/;"	f
findChart	./parse.c	/^int findChart( int idx ) {$/;"	f
findChart	./wcrt/parse.c	/^int findChart( int idx ) {$/;"	f
findCriticalPath	./timing.c	/^int findCriticalPath( chart_t *msc ) {$/;"	f
findCriticalPath	./wcrt/timing.c	/^int findCriticalPath( chart_t *msc ) {$/;"	f
findMainProc	./parseCFG.c	/^int findMainProc( int mainaddr ) {$/;"	f
findPE	./parse.c	/^int findPE( int id ) {$/;"	f
findPE	./wcrt/parse.c	/^int findPE( int id ) {$/;"	f
findReg	./infeasible.c	/^int findReg( char key[] ) {$/;"	f
findTask	./parse.c	/^int findTask( char tname[] ) {$/;"	f
findTask	./wcrt/parse.c	/^int findTask( char tname[] ) {$/;"	f
find_WCETPath	./DAG_WCET.c	/^path* find_WCETPath( int pid, block **bblist, int num_bb, int *in_degree, uint *cost ) {$/;"	f
finish_time	./header.h	/^ ull finish_time;$/;"	m	struct:__anon17
firstAlloc	./wcrt/alloc.c	/^int firstAlloc() {$/;"	f
fixPointCacheState	./analysisCache.c	/^ fixPointCacheState(cache_state *cs_ptr, loop *lp)$/;"	f	file:
fixPointCacheState_L2	./analysisCacheL2.c	/^fixPointCacheState_L2(cache_state *cs_ptr, loop *lp)$/;"	f	file:
fixedPointCalcHi	./timing.c	/^time_t fixedPointCalcHi( chart_t *msc, int idx ) {$/;"	f
fixedPointCalcHi	./wcrt/timing.c	/^time_t fixedPointCalcHi( chart_t *msc, int idx ) {$/;"	f
fixedPointCalcLo	./timing.c	/^time_t fixedPointCalcLo( chart_t *msc, int idx ) {$/;"	f
fixedPointCalcLo	./wcrt/timing.c	/^time_t fixedPointCalcLo( chart_t *msc, int idx ) {$/;"	f
fnid	./wcrt/header.h	/^  int fnid, bbid;         \/\/ for analysis$/;"	m	struct:__anon7
freeAll	./parse.c	/^int freeAll() {$/;"	f
freeAll	./wcrt/parse.c	/^int freeAll() {$/;"	f
freeAllCacheState	./analysisCache.c	/^freeAllCacheState()$/;"	f	file:
freeAllFunction	./analysisCache.c	/^freeAllFunction(procedure *proc)$/;"	f	file:
freeAllFunction_L2	./analysisCacheL2.c	/^freeAllFunction_L2(procedure *proc)$/;"	f	file:
freeAllLoop	./analysisCache.c	/^freeAllLoop(procedure *proc, loop *lp)$/;"	f	file:
freeAllLoop_L2	./analysisCacheL2.c	/^freeAllLoop_L2(procedure *proc, loop *lp)$/;"	f	file:
freeAll_L2	./analysisCacheL2.c	/^freeAll_L2()$/;"	f	file:
freeAlloc	./parse.c	/^int freeAlloc( alloc_t *ac ) {$/;"	f
freeAlloc	./wcrt/parse.c	/^int freeAlloc( alloc_t *ac ) {$/;"	f
freeCacheSet	./analysisCache.c	/^freeCacheSet(cache_line_way_t **cache_set)$/;"	f	file:
freeCacheSet_L2	./analysisCacheL2.c	/^freeCacheSet_L2(cache_line_way_t **cache_set)$/;"	f	file:
freeCacheState	./analysisCache.c	/^freeCacheState(cache_state *cs)$/;"	f	file:
freeCacheStateFunction	./analysisCache.c	/^freeCacheStateFunction(procedure * proc)$/;"	f	file:
freeCacheStateFunction_L2	./analysisCacheL2.c	/^freeCacheStateFunction_L2(procedure * proc)$/;"	f	file:
freeCacheStateLoop	./analysisCache.c	/^freeCacheStateLoop(procedure *proc, loop *lp)$/;"	f	file:
freeCacheStateLoop_L2	./analysisCacheL2.c	/^freeCacheStateLoop_L2(procedure *proc, loop *lp)$/;"	f	file:
freeCacheState_L2	./analysisCacheL2.c	/^freeCacheState_L2(cache_state *cs)$/;"	f	file:
freeChart	./parse.c	/^int freeChart( chart_t *cx ) {$/;"	f
freeChart	./wcrt/parse.c	/^int freeChart( chart_t *cx ) {$/;"	f
freePath	./parse.c	/^int freePath( path_t *px ) {$/;"	f
freePath	./path.c	/^int freePath( int bbid, int ptid ) {$/;"	f
freePath	./wcrt/parse.c	/^int freePath( path_t *px ) {$/;"	f
freePathsInNode	./path.c	/^int freePathsInNode( int bbid ) {$/;"	f
freeSched	./parse.c	/^int freeSched( sched_t *sc ) {$/;"	f
freeSched	./wcrt/parse.c	/^int freeSched( sched_t *sc ) {$/;"	f
freeTask	./parse.c	/^int freeTask( task_t *tx ) {$/;"	f
freeTask	./wcrt/parse.c	/^int freeTask( task_t *tx ) {$/;"	f
freq	./wcrt/header.h	/^  int freq;               \/\/ access frequency$/;"	m	struct:__anon7
g_independent_task	./header.h	/^uint g_independent_task;$/;"	v
g_no_bus_modeling	./header.h	/^uint g_no_bus_modeling;$/;"	v
g_optimized	./header.h	/^int g_optimized;$/;"	v
g_private	./header.h	/^uint g_private;$/;"	v
g_shared_bus	./header.h	/^uint g_shared_bus;$/;"	v
g_testing_mode	./header.h	/^uint g_testing_mode;$/;"	v
generateWeiConflict	./slacks.c	/^generateWeiConflict(chart_t *msc)$/;"	f	file:
generateWeiConflict	./wcrt/slacks.c	/^generateWeiConflict(chart_t *msc)$/;"	f	file:
getAllocatedSize	./slacks.c	/^int getAllocatedSize( task_t *ts ) {$/;"	f
getAllocatedSize	./wcrt/slacks.c	/^int getAllocatedSize( task_t *ts ) {$/;"	f
getBlockExecCount	./analysisILP.c	/^int getBlockExecCount( block *bb ) {$/;"	f
getCallee	./analysisDAG_WCET.c	/^procedure* getCallee(instr* inst, procedure* proc)$/;"	f
getIndexInList	./wcrt/util.c	/^int getIndexInList( int element, int *arr, int len ) {$/;"	f
getJumpDest	./block.c	/^char *getJumpDest( instr *insn ) {$/;"	f
getNextValidSuccId	./timingMSG.c	/^int getNextValidSuccId( path_t *px, int chartid, int from ) {$/;"	f
getNextValidSuccId	./wcrt/timingMSG.c	/^int getNextValidSuccId( path_t *px, int chartid, int from ) {$/;"	f
getNumFetch	./analysis.c	/^int getNumFetch( int size ) {$/;"	f
getNumFetch	./wcrt/analysis.c	/^int getNumFetch( int size ) {$/;"	f
getTaskName	./wcrt/dump.c	/^char* getTaskName( int pidx ) {$/;"	f
get_core	./analysisDAG_WCET.c	/^uint get_core(task_t* cur_task)$/;"	f
get_earliest_start_time	./analysisDAG_WCET.c	/^static ull get_earliest_start_time(task_t* cur_task, uint core)$/;"	f	file:
get_hex	./analysisDAG_WCET.c	/^static uint get_hex(char* hex_string)$/;"	f	file:
get_latest_start_time	./analysisDAG_WCET.c	/^static ull get_latest_start_time(task_t* cur_task, uint core)$/;"	f	file:
get_msc_id	./wcrt/slacks.c	/^uint get_msc_id(chart_t* msc, uint task_id)$/;"	f
get_task_callee	./analysisDAG_WCET.c	/^static procedure* get_task_callee(uint startaddr)$/;"	f	file:
getblock	./block.c	/^int getblock( int bbid, block **bblist, int start, int end ) {$/;"	f
getticks	./main.c	/^static __inline__ ticks getticks(void)$/;"	f	file:
global_sched_data	./header.h	/^sched_p global_sched_data;$/;"	v
graphColoring	./wcrt/graphcoloring.c	/^int graphColoring( int numNodes, int *outdegree, int **outedges, char **colorAssg ) {$/;"	f
gxCalcHi	./timing.c	/^time_t gxCalcHi( chart_t *msc, int idx, time_t x ) {$/;"	f
gxCalcHi	./wcrt/timing.c	/^time_t gxCalcHi( chart_t *msc, int idx, time_t x ) {$/;"	f
gxCalcLo	./timing.c	/^time_t gxCalcLo( chart_t *msc, int idx, time_t x ) {$/;"	f
gxCalcLo	./wcrt/timing.c	/^time_t gxCalcLo( chart_t *msc, int idx, time_t x ) {$/;"	f
hasConflict	./pathTest.c	/^int hasConflict(int effectNo){$/;"	f
hasEdge	./path.c	/^char hasEdge( path *p, branch *br, char dir ) {$/;"	f
hasIncomingConflict	./DAG_WCET.c	/^char hasIncomingConflict( branch *br, char dir, block **bblist, int start, int num_bb ) {$/;"	f
hexValue	./block.c	/^int hexValue( char *hexStr ) {$/;"	f
hit	./header.h	/^    int hit, miss, unknow;$/;"	m	struct:__anon14
hit_addr	./header.h	/^    int *hit_addr, *miss_addr, *unknow_addr;$/;"	m	struct:__anon14
hit_addr	./header.h	/^  cache_line_way_t *hit_addr;$/;"	m	struct:procs
hit_bcet	./header.h	/^    ull hit_bcet;$/;"	m	struct:__anon20
hit_bcet	./header.h	/^  ull   *hit_bcet;$/;"	m	struct:__anon18
hit_bcet	./header.h	/^  ull   *hit_bcet;$/;"	m	struct:procs
hit_bcet_L2	./header.h	/^    ull hit_bcet_L2;$/;"	m	struct:__anon20
hit_bcet_L2	./header.h	/^  ull   *hit_bcet_L2;$/;"	m	struct:__anon18
hit_bcet_L2	./header.h	/^  ull   *hit_bcet_L2;$/;"	m	struct:procs
hit_cache_set_L2	./header.h	/^  char *hit_cache_set_L2;$/;"	m	struct:procs
hit_change_miss	./header.h	/^    char *hit_change_miss, *age;$/;"	m	struct:__anon14
hit_copy	./header.h	/^    int hit_copy;$/;"	m	struct:__anon14
hit_wcet	./header.h	/^    ull hit_wcet;$/;"	m	struct:__anon20
hit_wcet	./header.h	/^  ull   *hit_wcet;$/;"	m	struct:__anon18
hit_wcet	./header.h	/^  ull   *hit_wcet;$/;"	m	struct:procs
hit_wcet_L2	./header.h	/^    ull hit_wcet_L2;$/;"	m	struct:__anon20
hit_wcet_L2	./header.h	/^  ull   *hit_wcet_L2;$/;"	m	struct:__anon18
hit_wcet_L2	./header.h	/^  ull   *hit_wcet_L2;$/;"	m	struct:procs
hitmiss	./header.h	/^    int hitmiss;$/;"	m	struct:__anon14
hitmiss_addr	./header.h	/^    char *hitmiss_addr;$/;"	m	struct:__anon14
identicalConflict	./path.c	/^char identicalConflict( path *p1, path *p2 ) {$/;"	f
ilpf	./analysis.h	/^FILE *ilpf;$/;"	v
imin	./wcrt/util.c	/^int imin( int a, int b ) {$/;"	f
inExits	./loopdetect.c	/^int inExits( int id, block **exits, int num_exits ) {$/;"	f
inList	./wcrt/util.c	/^char inList( int element, int *arr, int len ) {$/;"	f
inProcRange	./block.c	/^int inProcRange( int addr, procedure *p ) {$/;"	f
in_conflict	./infeasible.h	/^  char   *in_conflict;         \/\/ in_conflict[i] = 1 if block i is incoming conflict, i: 0...proc->num_bb$/;"	m	struct:brch
in_seq_bef	./DAG_WCET.c	/^char in_seq_bef( int bbid, int target, int *bb_seq, int bb_len ) {$/;"	f
incoming	./header.h	/^  int   *incoming;      \/\/ destination id-s of outgoing edges (at most 2)$/;"	m	struct:__anon17
indexOfProc	./handler.c	/^indexOfProc(int num)$/;"	f	file:
infeas	./header.h	/^char infeas;            \/\/ infeasibility checking on\/off $/;"	v
initAlloc	./wcrt/alloc.c	/^int initAlloc( chart_t *msc ) {$/;"	f
initChart	./parse.c	/^int initChart( chart_t *cx ) {$/;"	f
initChart	./wcrt/parse.c	/^int initChart( chart_t *cx ) {$/;"	f
initInfeas	./infeasible.c	/^int initInfeas() {$/;"	f
initPath	./timingMSG.c	/^int initPath( path_t *px ) {$/;"	f
initPath	./wcrt/timingMSG.c	/^int initPath( path_t *px ) {$/;"	f
initRegSet	./infeasible.c	/^int initRegSet() {$/;"	f
initSched	./parse.c	/^int initSched( sched_t *sc ) {$/;"	f
initSched	./wcrt/parse.c	/^int initSched( sched_t *sc ) {$/;"	f
insertSlacks	./slacks.c	/^int insertSlacks( chart_t *msc ) {$/;"	f
insertSlacks	./wcrt/slacks.c	/^int insertSlacks( chart_t *msc ) {$/;"	f
instr	./header.h	/^} instr;$/;"	t	typeref:struct:__anon12
instr	./infeasible.h	/^  char instr;                  \/\/ any special kind of instruction; -1 if not specified 	$/;"	m	struct:__anon1
instr_per_block	./header.h	/^int instr_per_block;$/;"	v
instr_per_block_L2	./header.h	/^int instr_per_block_L2;$/;"	v
instrlist	./header.h	/^  instr **instrlist;    \/\/ list of assembly instructions in the block$/;"	m	struct:__anon17
interferInfo	./header.h	/^    int **interferInfo;$/;"	m	struct:__anon21
interfere	./wcrt/header.h	/^char **interfere;$/;"	v
interferePathName	./header.h	/^char *interferePathName;$/;"	v
intersectCacheState	./analysisCache.c	/^intersectCacheState(cache_line_way_t **clw_a, cache_line_way_t **clw_b)$/;"	f	file:
intersectCacheState_L2	./analysisCacheL2.c	/^intersectCacheState_L2(cache_line_way_t **clw_a, cache_line_way_t **clw_b)$/;"	f	file:
interval	./header.h	/^	uint interval;	 \/* time interval between two consecutive slots of the same core *\/ $/;"	m	struct:core_sched
isAssignInstr	./block.c	/^char isAssignInstr( instr *insn ) {$/;"	f
isBAConflict	./infeasible.c	/^char isBAConflict( assign *A, branch *B, int r ) {  $/;"	f
isBBConflict	./infeasible.c	/^char isBBConflict( branch *A, branch *B, int r1, int r2 ) {  $/;"	f
isBranchInstr	./block.c	/^char isBranchInstr( instr *insn ) {$/;"	f
isCritical	./wcrt/header.h	/^char *isCritical;         \/\/ isCritical[i] = 1 if taskList[i] is in the critical path of its MSC, 0 otherwise$/;"	v
isFeasible	./pathTest.c	/^int isFeasible(int p[],int length){$/;"	f
isInCache	./analysisCache.c	/^isInCache(int addr, cache_line_way_t**must)$/;"	f	file:
isInCache_L2	./analysisCacheL2.c	/^isInCache_L2(int addr, cache_line_way_t**must)$/;"	f	file:
isInSet	./analysisCache.c	/^isInSet(int addr, cache_line_way_t **set)$/;"	f	file:
isInSet_L2	./analysisCacheL2.c	/^isInSet_L2(int addr, cache_line_way_t **set)$/;"	f	file:
isInSet_L2_persist	./analysisCacheL2.c	/^isInSet_L2_persist(int addr, cache_line_way_t **set)$/;"	f	file:
isInSet_persist	./analysisCache.c	/^isInSet_persist(int addr, cache_line_way_t **set)$/;"	f	file:
isInWay	./analysisCache.c	/^isInWay(int entry, int *entries, int num_entry)$/;"	f	file:
isNeverInCache	./analysisCache.c	/^isNeverInCache(int addr, cache_line_way_t**may)$/;"	f	file:
isNeverInCache_L2	./analysisCacheL2.c	/^isNeverInCache_L2(int addr, cache_line_way_t**may)$/;"	f	file:
isPred	./wcrt/timing.c	/^isPred(chart_t *msc, int id, int pred)$/;"	f	file:
isPredecessorOf	./parse.c	/^char isPredecessorOf( int pred, int succ ) {$/;"	f
isPredecessorOf	./wcrt/parse.c	/^char isPredecessorOf( int pred, int succ ) {$/;"	f
isReachable	./loopdetect.c	/^int isReachable( int src, int dest, block **bblist, int num_bb ) {$/;"	f
isReachableNoCancel	./findConflicts.c	/^char isReachableNoCancel( int pid, int srcid, int destid, char *deri_tree,$/;"	f
isReachableTopo	./analysisILP.c	/^int isReachableTopo( block *src, int dest, block **bblist, int start, int end ) {$/;"	f
is_dowhile	./header.h	/^  char  is_dowhile;     \/\/ indicates if the loop is a do-while loop (0\/1)$/;"	m	struct:__anon18
is_loophead	./header.h	/^  char  is_loophead;$/;"	m	struct:__anon17
jump_cond	./infeasible.h	/^  char   jump_cond;            \/\/ condition that makes a branch instruction jump$/;"	m	struct:brch
l_msk	./header.h	/^    uint    l_msk;  \/\/ block mask$/;"	m	struct:__anon13
l_start	./header.h	/^	 ull l_start;	  $/;"	m	struct:__anon20
latest	./header.h	/^ull* latest;$/;"	v
latestFin	./wcrt/header.h	/^time_t *latestFin;$/;"	v
latestReq	./wcrt/header.h	/^time_t *latestReq;$/;"	v
latestReq_copy	./wcrt/header.h	/^time_t *latestReq_copy;$/;"	v
latestTimes	./timing.c	/^char latestTimes( chart_t *msc, int *topoArr, int toposize ) {$/;"	f
latestTimes	./wcrt/timing.c	/^char latestTimes( chart_t *msc, int *topoArr, int toposize ) {$/;"	f
latestTimes_slack	./slacks.c	/^char latestTimes_slack( chart_t *msc, int *topoArr, int toposize ) {$/;"	f
latestTimes_slack	./wcrt/slacks.c	/^char latestTimes_slack( chart_t *msc, int *topoArr, int toposize ) {$/;"	f
latest_bus	./header.h	/^ ull latest_bus[64];$/;"	m	struct:__anon17
latest_latency	./header.h	/^ ull latest_latency[64];$/;"	m	struct:__anon17
level	./header.h	/^  int   level;          \/\/ nesting level of the loop, outmost being 0$/;"	m	struct:__anon18
lineno	./infeasible.h	/^  int    lineno;               \/\/ line number in bb$/;"	m	struct:__anon2
logBase2	./analysisCache.c	/^logBase2(int n)$/;"	f	file:
loop	./header.h	/^}loop;$/;"	t	typeref:struct:__anon18
loop_level_arr	./header.h	/^int *loop_level_arr;$/;"	v
loopbound	./header.h	/^  int   loopbound;      \/\/ max. number of loop iterations$/;"	m	struct:__anon18
loopexit	./header.h	/^  block *loopexit;      \/\/ pointer to the (normal) exit block of the loop$/;"	m	struct:__anon18
loophead	./header.h	/^  block *loophead;      \/\/ pointer to the block that heads the loop$/;"	m	struct:__anon18
loopid	./header.h	/^  int   loopid;         \/\/ id of the (innermost) loop it participates in; -1 if not in loop$/;"	m	struct:__anon17
loops	./header.h	/^  loop  **loops;        \/\/ list of loops in the procedure$/;"	m	struct:procs
loopsink	./header.h	/^  block *loopsink;      \/\/ pointer to the block that is the sink of the loop$/;"	m	struct:__anon18
lpid	./header.h	/^  int   lpid;$/;"	m	struct:__anon18
ls	./header.h	/^    int     ls;     \/\/ cache line size$/;"	m	struct:__anon13
lsb	./header.h	/^    int     lsb;        \/\/ lsb = log2(ls)$/;"	m	struct:__anon13
main	./main.c	/^int main(int argc, char **argv ) {$/;"	f
main	./wcrt/main.c	/^int main( int argc, char *argv[] ) {$/;"	f
main_copy	./header.h	/^    procedure *main_copy;$/;"	m	struct:__anon20
main_copy	./header.h	/^procedure *main_copy;$/;"	v
main_id	./header.h	/^int  main_id;           \/\/ id of main procedure$/;"	v
main_unused	./main.c	/^int main_unused( int argc, char **argv ) {$/;"	f
mapDependency	./timingMSG.c	/^int mapDependency( task_t *tc, int *map ) {$/;"	f
mapDependency	./wcrt/timingMSG.c	/^int mapDependency( task_t *tc, int *map ) {$/;"	f
mapFunctionCall	./analysisCache.c	/^mapFunctionCall(procedure *proc, cache_state *cs)$/;"	f	file:
mapFunctionCall_L2	./analysisCacheL2.c	/^mapFunctionCall_L2(procedure *proc, cache_state *cs)$/;"	f	file:
mapLoop	./analysisCache.c	/^mapLoop(procedure *proc, loop *lp)$/;"	f	file:
mapLoop_L2	./analysisCacheL2.c	/^mapLoop_L2(procedure *pro, loop *lp)$/;"	f	file:
max_paths	./infeasible.h	/^int  max_paths; $/;"	v
may	./header.h	/^    cache_line_way_t *** may;         \/\/may cache state$/;"	m	struct:__anon16
memBlockList	./wcrt/header.h	/^  mem_t  **memBlockList;$/;"	m	struct:__anon8
mem_addr	./infeasible.h	/^  char mem_addr[DERI_LEN];     \/\/ a sequence of operations on mem. accesses$/;"	m	struct:__anon1
mem_t	./wcrt/header.h	/^} mem_t;$/;"	t	typeref:struct:__anon7
method	./header.h	/^int  method;            \/\/ analysis methods: ILP\/DAG\/ENUM$/;"	v
miss	./header.h	/^    int hit, miss, unknow;$/;"	m	struct:__anon14
miss_addr	./header.h	/^    int *hit_addr, *miss_addr, *unknow_addr;$/;"	m	struct:__anon14
miss_bcet	./header.h	/^    ull miss_bcet;$/;"	m	struct:__anon20
miss_bcet	./header.h	/^  ull   *miss_bcet;$/;"	m	struct:__anon18
miss_bcet	./header.h	/^  ull   *miss_bcet;$/;"	m	struct:procs
miss_bcet_L2	./header.h	/^    ull miss_bcet_L2;$/;"	m	struct:__anon20
miss_bcet_L2	./header.h	/^  ull   *miss_bcet_L2;$/;"	m	struct:__anon18
miss_bcet_L2	./header.h	/^  ull   *miss_bcet_L2;$/;"	m	struct:procs
miss_wcet	./header.h	/^    ull miss_wcet;$/;"	m	struct:__anon20
miss_wcet	./header.h	/^  ull   *miss_wcet;$/;"	m	struct:__anon18
miss_wcet	./header.h	/^  ull   *miss_wcet;$/;"	m	struct:procs
miss_wcet_L2	./header.h	/^    ull miss_wcet_L2;$/;"	m	struct:__anon20
miss_wcet_L2	./header.h	/^  ull   *miss_wcet_L2;$/;"	m	struct:__anon18
miss_wcet_L2	./header.h	/^  ull   *miss_wcet_L2;$/;"	m	struct:procs
modifiedInLoop	./findConflicts.c	/^char modifiedInLoop( loop *lp, char *deri_tree ) {$/;"	f
msc	./header.h	/^MSC **msc;$/;"	v
msc	./wcrt/header.h	/^  chart_t *msc;$/;"	m	struct:__anon11
msc_name	./header.h	/^    char msc_name[MAX_LEN];$/;"	m	struct:__anon21
msg	./wcrt/header.h	/^chart_t *msg;$/;"	v
must	./header.h	/^    cache_line_way_t *** must;        \/\/must cache state$/;"	m	struct:__anon16
mymod	./wcrt/util.c	/^int mymod( int a, int b ) {$/;"	f
n_cores	./header.h	/^	uint n_cores;	      \/* number of cores active *\/ 	$/;"	m	struct:schedule
n_segments	./header.h	/^	uint n_segments;	   \/* number of segments in the full schedule *\/ 	$/;"	m	struct:schedule
na	./header.h	/^    int     na;     \/\/ #associativity$/;"	m	struct:__anon13
ncore	./header.h	/^uint ncore;$/;"	v
neg	./infeasible.c	/^int neg( int a ) {$/;"	f
nest	./header.h	/^  int   nest;           \/\/ id of the loop that this loop is immediately nested in (-1 if not nested)$/;"	m	struct:__anon18
nested	./loopdetect.c	/^int nested( int inloopid, int outloopid, loop **loops ) {$/;"	f
ns	./header.h	/^    int     ns;     \/\/ #sets$/;"	m	struct:__anon13
nsb	./header.h	/^    int     nsb;        \/\/ nsb = log2(ns)$/;"	m	struct:__anon13
nt	./header.h	/^    int     nt; \/\/ #tags$/;"	m	struct:__anon13
nt_s	./header.h	/^    int     nt_s;   \/\/ # of (tag + set)$/;"	m	struct:__anon13
ntb	./header.h	/^    int     ntb;    \/\/ tag bits = log2(nt)$/;"	m	struct:__anon13
numAssigned	./wcrt/header.h	/^  int numAssigned;$/;"	m	struct:__anon6
numCharts	./wcrt/header.h	/^int numCharts;            \/\/ number of MSC nodes in the MSG$/;"	v
numConflictMSC	./header.h	/^char *numConflictMSC; \/\/to sum up number of tasks that map to the same cache set within one MSC$/;"	v
numConflictTask	./header.h	/^char *numConflictTask; \/\/to sum up number of tasks that map to the same cache set$/;"	v
numEdgeBounds	./wcrt/header.h	/^int numEdgeBounds;$/;"	v
numMemBlocks	./wcrt/header.h	/^  int    numMemBlocks;$/;"	m	struct:__anon8
numOverlays	./wcrt/header.h	/^  int numOverlays;$/;"	m	struct:__anon5
numOwnerTasks	./wcrt/header.h	/^  int numOwnerTasks;$/;"	m	struct:__anon4
numPEs	./wcrt/header.h	/^int numPEs;$/;"	v
numPreds	./wcrt/header.h	/^  int    numPreds;$/;"	m	struct:__anon8
numSuccs	./header.h	/^	 int numSuccs;$/;"	m	struct:__anon20
numSuccs	./wcrt/header.h	/^  int    numSuccs;$/;"	m	struct:__anon8
numSuccs	./wcrt/header.h	/^  int  numSuccs;$/;"	m	struct:__anon9
numTasks	./wcrt/header.h	/^int numTasks;$/;"	v
num_BA	./infeasible.h	/^int num_BA;                    \/\/ #potential BA conflict pairs$/;"	v
num_BB	./infeasible.h	/^int num_BB;                    \/\/ #potential BB conflict pairs$/;"	v
num_access	./header.h	/^  int num_access; $/;"	m	struct:__anon17
num_active_incfs	./infeasible.h	/^  int    num_active_incfs;     \/\/ #unvisited blocks (assign\/branch) with incoming conflict$/;"	m	struct:brch
num_assign	./infeasible.h	/^int    **num_assign;           \/\/ num_assign[i][j]: #assign effects in proc i block j$/;"	v
num_bb	./header.h	/^  int   num_bb;$/;"	m	struct:procs
num_cache_fetch	./header.h	/^  int num_cache_fetch;    $/;"	m	struct:__anon17
num_cache_fetch_L2	./header.h	/^  int num_cache_fetch_L2;    $/;"	m	struct:__anon17
num_cache_state	./header.h	/^  int num_cache_state, num_cache_state_L2;$/;"	m	struct:__anon17
num_cache_state_L2	./header.h	/^  int num_cache_state, num_cache_state_L2;$/;"	m	struct:__anon17
num_calls	./header.h	/^  int   num_calls;$/;"	m	struct:procs
num_chmc	./header.h	/^  int num_chmc, num_chmc_L2;$/;"	m	struct:__anon17
num_chmc_L2	./header.h	/^  int num_chmc, num_chmc_L2;$/;"	m	struct:__anon17
num_conflicts	./infeasible.h	/^  int    num_conflicts;$/;"	m	struct:__anon2
num_conflicts	./infeasible.h	/^  int    num_conflicts;$/;"	m	struct:brch
num_core	./header.h	/^int num_core;$/;"	v
num_cost	./header.h	/^  int   num_cost;$/;"	m	struct:__anon18
num_cost	./header.h	/^  int   num_cost;$/;"	m	struct:procs
num_entry	./header.h	/^    unsigned short  num_entry;    \/\/ number of entries$/;"	m	struct:__anon15
num_fm	./header.h	/^  char num_fm;$/;"	m	struct:__anon18
num_fm_L2	./header.h	/^  char num_fm_L2;$/;"	m	struct:__anon18
num_incfs	./infeasible.h	/^  int    num_incfs;            \/\/ #blocks (assign\/branch) with incoming conflict$/;"	m	struct:brch
num_incoming	./header.h	/^  int  num_incoming;   \/\/ $/;"	m	struct:__anon17
num_instr	./header.h	/^  int   num_instr;$/;"	m	struct:__anon17
num_loops	./header.h	/^  int   num_loops;$/;"	m	struct:procs
num_outgoing	./header.h	/^  int  num_outgoing;   \/\/ 0, 1, or 2$/;"	m	struct:__anon17
num_outgoing_copy	./header.h	/^  int  num_outgoing_copy;$/;"	m	struct:__anon17
num_paths	./infeasible.h	/^int  *num_paths;$/;"	v
num_proc	./header.h	/^    int num_proc;$/;"	m	struct:__anon19
num_proc	./header.h	/^    int num_proc;$/;"	m	struct:__anon20
num_procs	./header.h	/^int  num_procs;$/;"	v
num_task	./header.h	/^    int num_task;$/;"	m	struct:__anon21
num_topo	./header.h	/^  int   num_topo;       \/\/ <= num_bb, as loops are excluded$/;"	m	struct:procs
num_topo	./header.h	/^  int   num_topo;$/;"	m	struct:__anon18
numregs	./header.h	/^int numregs;$/;"	v
off_latency	./wcrt/header.h	/^int off_latency;$/;"	v
op	./header.h	/^  char op[OP_LEN];$/;"	m	struct:__anon12
openfext	./wcrt/handler.c	/^FILE* openfext( char *filename, char *ext, char *mode ) {$/;"	f
openfile	./handler.c	/^FILE* openfile( char *ext, char *mode ) {$/;"	f
openfile	./wcrt/handler.c	/^FILE* openfile( char *filename, char *mode ) {$/;"	f
outgoing	./header.h	/^  int   *outgoing;      \/\/ destination id-s of outgoing edges (at most 2)$/;"	m	struct:__anon17
overlap	./wcrt/timing.c	/^static char overlap(int i, int j)$/;"	f	file:
overlayList	./wcrt/header.h	/^  overlay_t **overlayList;$/;"	m	struct:__anon5
overlay_t	./wcrt/header.h	/^} overlay_t;$/;"	t	typeref:struct:__anon4
ownerTaskList	./wcrt/header.h	/^  int *ownerTaskList;$/;"	m	struct:__anon4
pChart	./wcrt/header.h	/^int *pChart;              \/\/ pChart[i]: index of topoLists of the MSC containing taskList[i]$/;"	v
path	./infeasible.h	/^} path;$/;"	t	typeref:struct:__anon3
pathDAG	./pathDAG.c	/^pathDAG(MSC *msc)$/;"	f	file:
pathFreed	./infeasible.h	/^char *pathFreed;$/;"	v
pathFunction	./pathDAG.c	/^pathFunction(procedure *proc)$/;"	f	file:
pathLoop	./pathDAG.c	/^pathLoop(procedure *proc, loop *lp)$/;"	f	file:
path_t	./wcrt/header.h	/^} path_t;$/;"	t	typeref:struct:__anon11
pathlist	./infeasible.h	/^path ***pathlist;              \/\/ pathlist[i]: list of potential wcet paths collected at block i$/;"	v
pdname	./wcrt/header.h	/^char *pdname;$/;"	v
peID	./wcrt/header.h	/^  int    peID;$/;"	m	struct:__anon8
peID	./wcrt/header.h	/^int *peID;$/;"	v
peers	./wcrt/header.h	/^char **peers;$/;"	v
per_core_sched	./header.h	/^	core_sched_p* per_core_sched;	\/* Core wise schedule information *\/$/;"	m	struct:segment
period	./wcrt/header.h	/^  time_t period;$/;"	m	struct:__anon8
persist	./header.h	/^    cache_line_way_t *** persist;         \/\/persist cache state$/;"	m	struct:__anon16
pid	./header.h	/^  int   pid;            \/\/ id of the procedure it belongs to$/;"	m	struct:__anon17
pid	./header.h	/^  int   pid;            \/\/ id of the procedure it belongs to$/;"	m	struct:__anon18
pid	./header.h	/^  int   pid;$/;"	m	struct:procs
popNode	./timingMSG.c	/^int popNode( int *node, int *next, int **bpStack, int **nextSucc, int *len ) {$/;"	f
popNode	./wcrt/timingMSG.c	/^int popNode( int *node, int *next, int **bpStack, int **nextSucc, int *len ) {$/;"	f
predList	./wcrt/header.h	/^  int    *predList;        \/\/ task index (not pid!) of predecessors$/;"	m	struct:__anon8
preprocess_all_loops	./analysisDAG_WCET.c	/^static void preprocess_all_loops(procedure* proc)$/;"	f	file:
preprocess_chmc	./analysisDAG_WCET.c	/^static void preprocess_chmc(procedure* proc)$/;"	f	file:
preprocess_chmc_BCET	./analysisDAG_WCET.c	/^static void preprocess_chmc_BCET(procedure* proc)$/;"	f	file:
preprocess_chmc_L2	./analysisDAG_WCET.c	/^static void preprocess_chmc_L2(procedure* proc)$/;"	f	file:
preprocess_chmc_L2_BCET	./analysisDAG_WCET.c	/^static void preprocess_chmc_L2_BCET(procedure* proc)$/;"	f	file:
preprocess_one_loop	./analysisDAG_WCET.c	/^static void preprocess_one_loop(loop* lp, procedure* proc, ull start_time)$/;"	f	file:
print	./header.h	107;"	d
printAssign	./dump.c	/^int printAssign( assign *assg, int id, char printcf ) {$/;"	f
printBlock	./dump.c	/^int printBlock( block *bb ) {$/;"	f
printBlockInstr	./dump.c	/^int printBlockInstr( FILE *fptr, block *bb ) {$/;"	f
printBranch	./dump.c	/^int printBranch( branch *br, char printcf ) {$/;"	f
printInstr	./dump.c	/^int printInstr( FILE *fptr, instr *insn ) {$/;"	f
printLoop	./dump.c	/^int printLoop( loop *lp ) {$/;"	f
printMem	./wcrt/dump.c	/^int printMem( int pidx, char verbose ) {$/;"	f
printPE	./wcrt/dump.c	/^int printPE( int peID, int spmCapacity, sched_t *sc ) {$/;"	f
printPath	./dump.c	/^int printPath( path *pt ) {$/;"	f
printProc	./dump.c	/^int printProc( procedure *p ) {$/;"	f
printTask	./wcrt/dump.c	/^int printTask( int pidx ) {$/;"	f
printTaskList	./wcrt/dump.c	/^int printTaskList( chart_t *msc ) {$/;"	f
printTask_dep	./wcrt/dump.c	/^int printTask_dep( int pidx ) {$/;"	f
printTimes	./wcrt/dump.c	/^int printTimes( int idx ) {$/;"	f
printWCETLoop	./dump.c	/^int printWCETLoop( loop *lp ) {$/;"	f
printWCETProc	./dump.c	/^int printWCETProc( procedure *p ) {$/;"	f
print_cfg	./dump.c	/^int print_cfg() {$/;"	f
print_effects	./dump.c	/^int print_effects() {$/;"	f
print_instrlist	./dump.c	/^int print_instrlist() {$/;"	f
print_loops	./dump.c	/^int print_loops() {$/;"	f
print_topo	./dump.c	/^int print_topo() {$/;"	f
print_wcet	./dump.c	/^int print_wcet() {$/;"	f
priority	./wcrt/header.h	/^  int    priority;$/;"	m	struct:__anon8
proc	./header.h	/^    procedure **proc;$/;"	m	struct:__anon19
proc_cg	./header.h	/^int  *proc_cg;          \/\/ reverse topological order of procedure call graph$/;"	v
proc_cg_ptr	./header.h	/^    proc_copy *proc_cg_ptr;$/;"	m	struct:__anon20
proc_copy	./header.h	/^}proc_copy;$/;"	t	typeref:struct:__anon19
proc_ptr	./header.h	/^  struct procs* proc_ptr;$/;"	m	struct:__anon17	typeref:struct:__anon17::procs
procedure	./header.h	/^}procedure;$/;"	t	typeref:struct:procs
procs	./header.h	/^procedure **procs;      \/\/ list of procedures in the program$/;"	v
procs	./header.h	/^typedef struct procs {$/;"	s
promptLoopExit	./loopdetect.c	/^block *promptLoopExit( loop *lp, block **exits, int num_exits ) {$/;"	f
r1	./header.h	/^  char r1[OP_LEN];$/;"	m	struct:__anon12
r2	./header.h	/^  char r2[OP_LEN];$/;"	m	struct:__anon12
r3	./header.h	/^  char r3[OP_LEN];$/;"	m	struct:__anon12
reachable	./loopdetect.c	/^int reachable( int src, int dest, block **bblist, char *visited ) {$/;"	f
reachableNoCancel	./findConflicts.c	/^char reachableNoCancel( int pid, int srcid, int destid, char *deri_tree,$/;"	f
reachableTopo	./analysisILP.c	/^int reachableTopo( block *src, int dest, block **bblist, int start, int end, char *visited ) {$/;"	f
readConfig	./parse.c	/^int readConfig() {$/;"	f
readConfig	./wcrt/parse.c	/^int readConfig() {$/;"	f
readCost	./analysis.c	/^int readCost() {$/;"	f
readCost	./wcrt/analysis.c	/^int readCost() {$/;"	f
readEdgeBounds	./parse.c	/^int readEdgeBounds() {$/;"	f
readEdgeBounds	./wcrt/parse.c	/^int readEdgeBounds() {$/;"	f
readInstr	./parseCFG.c	/^int readInstr() {$/;"	f
readLoopExit	./loopdetect.c	/^char readLoopExit( loop *lp, block **exits, int num_exits ) {$/;"	f
readMSG	./parse.c	/^int readMSG() {$/;"	f
readMSG	./wcrt/parse.c	/^int readMSG() {$/;"	f
readMemoryReq	./parse.c	/^int readMemoryReq() {$/;"	f
readMemoryReq	./wcrt/parse.c	/^int readMemoryReq() {$/;"	f
readTaskMemoryReq	./parse.c	/^int readTaskMemoryReq( task_t *tc ) {$/;"	f
readTaskMemoryReq	./wcrt/parse.c	/^int readTaskMemoryReq( task_t *tc ) {$/;"	f
readTasks	./parse.c	/^int readTasks() {$/;"	f
readTasks	./wcrt/parse.c	/^int readTasks() {$/;"	f
read_arg	./parseCFG.c	/^int read_arg( int *lastaddr, int *mainaddr ) {$/;"	f
read_cfg	./parseCFG.c	/^int read_cfg() {$/;"	f
read_loop_annotation	./loopdetect.c	/^int read_loop_annotation() {$/;"	f
realsize	./wcrt/header.h	/^  int realsize;           \/\/ in the case that jumps are inserted because of allocation$/;"	m	struct:__anon7
recoverConcatDependency	./timingMSG.c	/^int recoverConcatDependency( int *predRecord, int *succRecord, int recordLen ) {$/;"	f
recoverConcatDependency	./wcrt/timingMSG.c	/^int recoverConcatDependency( int *predRecord, int *succRecord, int recordLen ) {$/;"	f
reg2Mem	./infeasible.h	/^deri_tree reg2Mem[NO_REG];     \/\/ reg2Mem[i]: current memory address of register i$/;"	v
regName	./infeasible.h	/^char regName[NO_REG][OP_LEN];$/;"	v
regioncost	./header.h	/^uint *regioncost;$/;"	v
regionmode	./header.h	/^int regionmode; $/;"	v
removeBackEdges	./loopdetect.c	/^int removeBackEdges( loop **loops, int num_loops ) {$/;"	f
removeBranch	./path.c	/^int removeBranch( path *pt, int bri ) {$/;"	f
removeEdge	./loopdetect.c	/^int removeEdge( block *bb, char outid ) {$/;"	f
removeExitEdges	./loopdetect.c	/^int removeExitEdges( procedure *p ) {$/;"	f
removeLoopComponent	./loopdetect.c	/^int removeLoopComponent( loop *lp, int bbid ) {$/;"	f
resetAllocation	./wcrt/alloc.c	/^int resetAllocation( chart_t *msc ) {$/;"	f
resetFunction_L2	./analysisCacheL2.c	/^resetFunction_L2(procedure * proc)$/;"	f	file:
resetHitMiss_L2	./analysisCacheL2.c	/^resetHitMiss_L2(MSC *msc)$/;"	f	file:
resetInterference	./slacks.c	/^int resetInterference( chart_t *msc ) {$/;"	f
resetInterference	./wcrt/slacks.c	/^int resetInterference( chart_t *msc ) {$/;"	f
resetLoop_L2	./analysisCacheL2.c	/^resetLoop_L2(procedure * proc, loop * lp)$/;"	f	file:
reset_all_task	./analysisDAG_WCET.c	/^static void reset_all_task(MSC* msc)$/;"	f	file:
reset_timestamps	./analysisDAG_WCET.c	/^static void reset_timestamps(procedure* proc, ull start_time)$/;"	f	file:
restoreIncomingConflicts	./DAG_WCET.c	/^int restoreIncomingConflicts() {$/;"	f
rhs	./infeasible.h	/^  int    rhs;                  \/\/ the rhs constant$/;"	m	struct:__anon2
rhs	./infeasible.h	/^  int    rhs;                  \/\/ the rhs constant$/;"	m	struct:brch
rhs_var	./infeasible.h	/^  char   rhs_var;              \/\/ 1 if rhs is a variable$/;"	m	struct:__anon2
rhs_var	./infeasible.h	/^  char   rhs_var;              \/\/ 1 if rhs is a variable$/;"	m	struct:brch
running_cost	./header.h	/^  ull running_cost;$/;"	m	struct:procs
running_finish_time	./header.h	/^  ull running_finish_time;$/;"	m	struct:procs
s_lb	./header.h	/^    int     s_lb;   \/\/ (set + line) bits$/;"	m	struct:__anon13
s_msk	./header.h	/^    uint    s_msk;  \/\/ set mask$/;"	m	struct:__anon13
sched_p	./header.h	/^typedef struct schedule* sched_p;$/;"	t	typeref:struct:schedule
sched_s	./header.h	/^typedef struct schedule sched_s;$/;"	t	typeref:struct:schedule
sched_t	./wcrt/header.h	/^} sched_t;$/;"	t	typeref:struct:__anon6
sched_type	./header.h	/^} sched_type;$/;"	t	typeref:enum:__anon22
schedule	./header.h	/^struct schedule {$/;"	s
searchBBlist	./block.c	/^block* searchBBlist( int addr, block **bblist, int len ) {$/;"	f
seg_end	./header.h	/^	ull seg_end;	 \/* ending time of the segment *\/	$/;"	m	struct:segment
seg_list	./header.h	/^	segment_p* seg_list; \/* list of segments in the whole schedule length *\/	$/;"	m	struct:schedule
seg_start	./header.h	/^	ull seg_start;	 \/* starting time of the segment *\/	$/;"	m	struct:segment
segment	./header.h	/^struct segment {$/;"	s
segment_p	./header.h	/^typedef struct segment* segment_p;$/;"	t	typeref:struct:segment
segment_s	./header.h	/^typedef struct segment segment_s;$/;"	t	typeref:struct:segment
setBAConflict	./findConflicts.c	/^int setBAConflict( assign *assg, branch *br, int id, char dir ) {$/;"	f
setBBConflict	./findConflicts.c	/^int setBBConflict( branch *br1, branch *br2, char dir1, char dir2, char new ) {$/;"	f
setInterference	./slacks.c	/^int setInterference( chart_t *msc ) {$/;"	f
setInterference	./wcrt/slacks.c	/^int setInterference( chart_t *msc ) {$/;"	f
setReg2Mem	./findConflicts.c	/^int setReg2Mem( int pos, char mem_addr[], int value, int instr ) {$/;"	f
set_cache_basic	./analysisCache.c	/^set_cache_basic(char * configFile)$/;"	f	file:
set_cache_basic_L2	./analysisCacheL2.c	/^set_cache_basic_L2(char * configFile)$/;"	f	file:
set_start_time	./analysisDAG_WCET.c	/^static void set_start_time(block* bb, procedure* proc)$/;"	f	file:
set_start_time_BCET	./analysisDAG_WCET.c	/^static void set_start_time_BCET(block* bb, procedure* proc)$/;"	f	file:
set_start_time_opt	./analysisDAG_WCET.c	/^static void set_start_time_opt(block* bb, procedure* proc, uint context)$/;"	f	file:
size	./header.h	/^  uint  size;           \/\/ size of block in bytes$/;"	m	struct:__anon17
size	./wcrt/header.h	/^  int size;$/;"	m	struct:__anon7
slot_len	./header.h	/^	uint slot_len;	 \/* slot length of the core in this segment *\/	$/;"	m	struct:core_sched
sortPath	./path.c	/^int sortPath( path **pathlist, int num_paths ) {$/;"	f
sortedInsertBranch	./path.c	/^int sortedInsertBranch( path *pt, branch *br, char dir ) {$/;"	f
spm	./wcrt/header.h	/^  alloc_t* spm;$/;"	m	struct:__anon6
spmCapacity	./wcrt/header.h	/^int *spmCapacity;$/;"	v
spm_latency	./wcrt/header.h	/^int spm_latency;$/;"	v
src	./wcrt/header.h	/^  int src;$/;"	m	struct:__anon10
startNode	./wcrt/header.h	/^int startNode;            \/\/ index of start node of the MSG$/;"	v
start_opt	./header.h	/^  ull start_opt[64];$/;"	m	struct:__anon18
start_opt	./header.h	/^ ull start_opt[64];$/;"	m	struct:__anon17
start_time	./header.h	/^	ull start_time; \/* starting time of the first slot for the core *\/	$/;"	m	struct:core_sched
start_time	./header.h	/^ ull start_time;$/;"	m	struct:__anon17
startaddr	./header.h	/^  int   startaddr;      \/\/ address of its first instruction$/;"	m	struct:__anon17
subsetConflict	./path.c	/^char subsetConflict( path *p1, path *p2 ) {$/;"	f
succList	./header.h	/^	 int* succList;$/;"	m	struct:__anon20
succList	./wcrt/header.h	/^  int    *succList;        \/\/ task index (not pid!) of successors$/;"	m	struct:__anon8
succList	./wcrt/header.h	/^  int  *succList;$/;"	m	struct:__anon9
t	./header.h	/^ double t;          \/\/record execution time$/;"	v
t_msk	./header.h	/^    uint    t_msk;  \/\/ tag mask$/;"	m	struct:__anon13
t_s_msk	./header.h	/^    uint    t_s_msk;\/\/ set+tag mask$/;"	m	struct:__anon13
t_sb	./header.h	/^    int     t_sb;   \/\/ (tag + set) bits$/;"	m	struct:__anon13
taskColoring	./wcrt/graphcoloring.c	/^int taskColoring( overlay_t *ox, char **colorAssg ) {$/;"	f
taskList	./header.h	/^    task_t *taskList;$/;"	m	struct:__anon21
taskList	./wcrt/header.h	/^task_t **taskList;        \/\/ global task list$/;"	v
task_id	./header.h	/^    int task_id;$/;"	m	struct:__anon20
task_name	./header.h	/^    char task_name[MAX_LEN];$/;"	m	struct:__anon20
task_t	./header.h	/^}task_t;$/;"	t	typeref:struct:__anon20
task_t	./wcrt/header.h	/^} task_t;$/;"	t	typeref:struct:__anon8
testBlockRange	./block.c	/^int testBlockRange( int addr, block *bb ) {$/;"	f
testConflict	./infeasible.c	/^char testConflict( int a, int rhs_a, int b, int rhs_b ) {$/;"	f
test_cs_op	./analysisCache.c	/^test_cs_op()$/;"	f	file:
testopen	./wcrt/handler.c	/^char testopen( char *filename ) {$/;"	f
testopenfext	./wcrt/handler.c	/^char testopenfext( char *filename, char *ext ) {$/;"	f
ticks	./main.c	/^typedef unsigned long long ticks;$/;"	t	file:
timeTopoList	./wcrt/header.h	/^  int  *timeTopoList;      \/\/ updating order based on topology and current scheduling, for safe slack insertion$/;"	m	struct:__anon9
time_t	./wcrt/header.h	1;"	d
timefp	./wcrt/main.c	/^FILE* timefp;$/;"	v
times_iteration	./header.h	/^int times_iteration;$/;"	v
times_iteration	./wcrt/header.h	/^char *times_iteration;$/;"	v
timingAllocMSC	./wcrt/alloc.c	/^int timingAllocMSC( chart_t *msc ) {$/;"	f
timingAllocMSC_slackCritical	./wcrt/alloc.c	/^int timingAllocMSC_slackCritical( chart_t *msc ) {$/;"	f
timingEstimate	./timingMSG.c	/^int timingEstimate() {$/;"	f
timingEstimate	./wcrt/timingMSG.c	/^int timingEstimate() {$/;"	f
timingEstimateMSC	./timing.c	/^int timingEstimateMSC( chart_t *msc ) {$/;"	f
timingEstimateMSC	./wcrt/timing.c	/^int timingEstimateMSC( chart_t *msc )$/;"	f
timingEstimate_asynch	./timingMSG.c	/^int timingEstimate_asynch() {$/;"	f
timingEstimate_asynch	./wcrt/timingMSG.c	/^int timingEstimate_asynch() {$/;"	f
timingEstimate_asynch_	./timingMSG.c	/^int timingEstimate_asynch_() {$/;"	f
timingEstimate_asynch_	./wcrt/timingMSG.c	/^int timingEstimate_asynch_() {$/;"	f
timingEstimate_asynch_acyclic	./timingMSG.c	/^int timingEstimate_asynch_acyclic() {$/;"	f
timingEstimate_asynch_acyclic	./wcrt/timingMSG.c	/^int timingEstimate_asynch_acyclic() {$/;"	f
timingEstimate_synch	./timingMSG.c	/^int timingEstimate_synch() {$/;"	f
timingEstimate_synch	./wcrt/timingMSG.c	/^int timingEstimate_synch() {$/;"	f
timingEstimate_synch_acyclic	./timingMSG.c	/^int timingEstimate_synch_acyclic() {$/;"	f
timingEstimate_synch_acyclic	./wcrt/timingMSG.c	/^int timingEstimate_synch_acyclic() {$/;"	f
tmEnd	./wcrt/header.h	/^  time_t tmEnd;$/;"	m	struct:__anon4
tmStart	./wcrt/header.h	/^  time_t tmStart;$/;"	m	struct:__anon4
tmax	./wcrt/util.c	/^time_t tmax( time_t a, time_t b ) {$/;"	f
tname	./wcrt/header.h	/^  char   tname[MAXLEN];$/;"	m	struct:__anon8
topo	./header.h	/^  block **topo;         \/\/ topologically sorted pointers to blocks in bblist, excluding loops$/;"	m	struct:procs
topo	./header.h	/^  block **topo;         \/\/ topologically sorted pointers to the blocks it contains, excluding nested loops$/;"	m	struct:__anon18
topoGraph	./wcrt/topo.c	/^int topoGraph() {$/;"	f
topoList	./wcrt/header.h	/^  int  *topoList;$/;"	m	struct:__anon9
topoListLen	./wcrt/header.h	/^  int  topoListLen;$/;"	m	struct:__anon9
topoMSG	./wcrt/header.h	/^int *topoMSG;             \/\/ MSG with nodes topologically sorted, for traversal$/;"	v
topoSort	./wcrt/topo.c	/^int topoSort( int *taskIDList, int numChartTasks, int **topoArr ) {$/;"	f
topoSortSubgraph	./wcrt/topo.c	/^int topoSortSubgraph( int startid, int **topoArr ) {$/;"	f
topoTask	./wcrt/topo.c	/^int topoTask() {$/;"	f
topo_call	./parseCFG.c	/^int topo_call() {$/;"	f
topo_sort	./topo.c	/^int topo_sort() {$/;"	f
topo_sort_loop	./topo.c	/^int topo_sort_loop( loop *lp ) {$/;"	f
topo_sort_proc	./topo.c	/^int topo_sort_proc( procedure *p ) {$/;"	f
total_bb	./header.h	/^int  total_bb;          \/\/ total number of basic blocks in the whole program$/;"	v
totalcapacity	./wcrt/header.h	/^int totalcapacity;$/;"	v
traverse	./DAG_WCET.c	/^int traverse( int pid, block **bblist, int num_bb, int *in_degree, uint *cost ) {$/;"	f
type	./header.h	/^	sched_type type;	   \/* type of the TDMA bus schedule *\/$/;"	m	struct:schedule
uint	./header.h	/^typedef unsigned int uint;$/;"	t
ull	./header.h	/^typedef unsigned long long ull;$/;"	t
unionCacheState	./analysisCache.c	/^unionCacheState(cache_line_way_t **clw_a, cache_line_way_t **clw_b)$/;"	f	file:
unionCacheState_L2	./analysisCacheL2.c	/^unionCacheState_L2(cache_line_way_t **clw_a, cache_line_way_t **clw_b)$/;"	f	file:
unionMaxCacheState	./analysisCache.c	/^unionMaxCacheState(cache_line_way_t **clw_a, cache_line_way_t **clw_b)$/;"	f	file:
unionMaxCacheState_L2	./analysisCacheL2.c	/^unionMaxCacheState_L2(cache_line_way_t **clw_a, cache_line_way_t **clw_b)$/;"	f	file:
unknow	./header.h	/^    int hit, miss, unknow;$/;"	m	struct:__anon14
unknow_addr	./header.h	/^    int *hit_addr, *miss_addr, *unknow_addr;$/;"	m	struct:__anon14
unknow_bcet	./header.h	/^    ull unknow_bcet;    $/;"	m	struct:__anon20
unknow_bcet	./header.h	/^  ull   *unknow_bcet;$/;"	m	struct:__anon18
unknow_bcet	./header.h	/^  ull   *unknow_bcet;$/;"	m	struct:procs
unknow_bcet_L2	./header.h	/^    ull unknow_bcet_L2; $/;"	m	struct:__anon20
unknow_bcet_L2	./header.h	/^  ull   *unknow_bcet_L2;$/;"	m	struct:__anon18
unknow_bcet_L2	./header.h	/^  ull   *unknow_bcet_L2;$/;"	m	struct:procs
unknow_copy	./header.h	/^    int unknow_copy;$/;"	m	struct:__anon14
unknow_wcet	./header.h	/^    ull unknow_wcet;    $/;"	m	struct:__anon20
unknow_wcet	./header.h	/^  ull   *unknow_wcet;$/;"	m	struct:__anon18
unknow_wcet	./header.h	/^  ull   *unknow_wcet;$/;"	m	struct:procs
unknow_wcet_L2	./header.h	/^    ull unknow_wcet_L2; $/;"	m	struct:__anon20
unknow_wcet_L2	./header.h	/^  ull   *unknow_wcet_L2;$/;"	m	struct:__anon18
unknow_wcet_L2	./header.h	/^  ull   *unknow_wcet_L2;$/;"	m	struct:procs
updateAllocation	./wcrt/alloc.c	/^char updateAllocation( int peID, chart_t *msc ) {$/;"	f
updateAllocationGC	./wcrt/alloc.c	/^int updateAllocationGC( sched_t *sc, chart_t *msc, int spmCapacity ) {$/;"	f
updateAllocationIC	./wcrt/alloc.c	/^int updateAllocationIC( sched_t *sc, chart_t *msc, int spmCapacity ) {$/;"	f
updateAllocationPK	./wcrt/alloc.c	/^int updateAllocationPK( sched_t *sc, chart_t *msc, int spmCapacity ) {$/;"	f
updateCacheState	./updateCacheL2.c	/^updateCacheState(MSC *msc)$/;"	f	file:
updateFunctionCall	./updateCacheL2.c	/^updateFunctionCall(MSC *msc, int index, procedure* proc)$/;"	f	file:
updateLoop	./updateCacheL2.c	/^updateLoop(MSC *msc, int index, procedure *proc, loop *lp)$/;"	f	file:
update_succ_earliest_time	./analysisDAG_WCET.c	/^static void update_succ_earliest_time(MSC* msc, task_t* task)$/;"	f	file:
update_succ_latest_time	./analysisDAG_WCET.c	/^static void update_succ_latest_time(MSC* msc, task_t* task)$/;"	f	file:
valid	./infeasible.h	/^  char valid;                  \/\/ 1 if value is a valid constant (not unresolved mem. access)$/;"	m	struct:__anon1
value	./infeasible.h	/^  int  value;                  \/\/ a constant; 0 if mem. access (not resolved)$/;"	m	struct:__anon1
wcet	./header.h	/^    ull wcet;$/;"	m	struct:__anon20
wcet	./header.h	/^  ull   *wcet;           \/\/ result of wcet analysis for this procedure$/;"	m	struct:__anon18
wcet	./header.h	/^  ull   *wcet;           \/\/ result of wcet analysis for this procedure$/;"	m	struct:procs
wcet_opt	./header.h	/^  ull wcet_opt[64];$/;"	m	struct:__anon18
wcost	./header.h	/^   uint  wcost;           \/\/ block execution time: worst case for cache analysis$/;"	m	struct:__anon14
wcost_copy	./header.h	/^   uint  wcost_copy;$/;"	m	struct:__anon14
wcrt	./wcrt/header.h	/^  time_t wcrt;             \/\/ WCRT of the chart$/;"	m	struct:__anon9
wpath	./header.h	/^  char  *wpath;         \/\/ wcet path, a binary sequence (as string) reflecting branch choices$/;"	m	struct:__anon18
wpath	./header.h	/^  char  *wpath;         \/\/ wcet path, a binary sequence (as string) reflecting branch choices$/;"	m	struct:procs
writeAllTime	./wcrt/slacks.c	/^static void writeAllTime(chart_t* msc, task_t* task, int id, FILE* fp)$/;"	f	file:
writeInterference	./slacks.c	/^     int writeInterference()$/;"	f
writeInterference	./wcrt/slacks.c	/^int writeInterference()$/;"	f
writeWeiConflict	./slacks.c	/^writeWeiConflict()$/;"	f	file:
writeWeiConflict	./wcrt/slacks.c	/^writeWeiConflict()$/;"	f	file:
