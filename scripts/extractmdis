#!/bin/bash

# Extracts source code part of the assembly.
# (i.e. discards compiler-generated functions, except the initializer at the very beginning)
# For purpose of variable mapping. Initializer section needed to calculate base address.

# Result written to $1.mdis
# Calls "findstr"

# By convention __do_global_dtors() is the first compiler-generated function
# following the source code functions.

#x=`findstr __do_global_dtors\(\) $1.dis | grep __do_global_dtors\(\) | awk '{ print $1 }'`
#x=`findstr __libc_init\(\) $1.dis | grep __libc_init\(\) | awk '{ print $1 }'`

x=`grep -inr __libc_init\(\) $1.dis | cut -d: -f1`

x=$(($x-1))
head -$x $1.dis > $1.mdis


# Extracts only the assembly instructions corresponding to source code
# (minus the intermixed source code, source line numbers, and initializer section).
# For purpose of conflict detection. Will be mapped to basic blocks later on.

sed '/__start/d' $1.mdis | grep ^[0-9] |\
awk '
{
  print $1, $3, $4
}' |\
tr ',' '\ ' | tr '(' '\ ' | tr ')' '\ ' > $1.md




#start=`awk '{ print $1 }' $1.arg`
#end=`awk '{ print $2 }' $1.arg`

# Don't know how to make awk read shell variable, so print the command to file.

#echo cat -n $1.dis \| awk \'\$2 \~/$start/{print \$1}\' > tawk
#chmod a+x tawk
#./tawk > startf

#startnum=`cat startf`

#echo cat -n $1.dis \| awk \'\$2 \~/$end/{print \$1}\' > tawk
#chmod a+x tawk
#./tawk > endf

#endnum=`cat endf`

#len=$(($endnum-$startnum))
#len=$(($len+1))

#head -$endnum $1.dis > $1.mdtmp
#tail -$len $1.mdtmp > $1.md

#rm $1.mdtmp


